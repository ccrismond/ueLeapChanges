// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Private/LeapMotionControllerPrivatePCH.h"
#include "LeapMotionController.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeLeapMotionController() {}
static class UEnum* ELeapBone_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern LEAPMOTIONCONTROLLER_API class UEnum* Z_Construct_UEnum_LeapMotionController_ELeapBone();
		extern LEAPMOTIONCONTROLLER_API class UPackage* Z_Construct_UPackage_LeapMotionController();
		Singleton = GetStaticEnum(Z_Construct_UEnum_LeapMotionController_ELeapBone, Z_Construct_UPackage_LeapMotionController(), TEXT("ELeapBone"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ELeapBone(ELeapBone_StaticEnum, TEXT("/Script/LeapMotionController"));
static class UEnum* ELeapSide_StaticEnum()
{
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern LEAPMOTIONCONTROLLER_API class UEnum* Z_Construct_UEnum_LeapMotionController_ELeapSide();
		extern LEAPMOTIONCONTROLLER_API class UPackage* Z_Construct_UPackage_LeapMotionController();
		Singleton = GetStaticEnum(Z_Construct_UEnum_LeapMotionController_ELeapSide, Z_Construct_UPackage_LeapMotionController(), TEXT("ELeapSide"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ELeapSide(ELeapSide_StaticEnum, TEXT("/Script/LeapMotionController"));
	void ULeapMotionTypes::StaticRegisterNativesULeapMotionTypes()
	{
	}
	IMPLEMENT_CLASS(ULeapMotionTypes, 2194794841);
	void ALeapMotionBoneActor::StaticRegisterNativesALeapMotionBoneActor()
	{
		FNativeFunctionRegistrar::RegisterFunction(ALeapMotionBoneActor::StaticClass(),"GetHandActor",(Native)&ALeapMotionBoneActor::execGetHandActor);
		FNativeFunctionRegistrar::RegisterFunction(ALeapMotionBoneActor::StaticClass(),"GetParentingControllerComponent",(Native)&ALeapMotionBoneActor::execGetParentingControllerComponent);
		FNativeFunctionRegistrar::RegisterFunction(ALeapMotionBoneActor::StaticClass(),"Init",(Native)&ALeapMotionBoneActor::execInit);
		FNativeFunctionRegistrar::RegisterFunction(ALeapMotionBoneActor::StaticClass(),"SetMeshForArm",(Native)&ALeapMotionBoneActor::execSetMeshForArm);
		FNativeFunctionRegistrar::RegisterFunction(ALeapMotionBoneActor::StaticClass(),"SetMeshForFinger",(Native)&ALeapMotionBoneActor::execSetMeshForFinger);
		FNativeFunctionRegistrar::RegisterFunction(ALeapMotionBoneActor::StaticClass(),"SetMeshForPalm",(Native)&ALeapMotionBoneActor::execSetMeshForPalm);
	}
	IMPLEMENT_CLASS(ALeapMotionBoneActor, 798461120);
	void ALeapMotionControllerActor::StaticRegisterNativesALeapMotionControllerActor()
	{
	}
	IMPLEMENT_CLASS(ALeapMotionControllerActor, 4092259627);
	void ULeapMotionControllerComponent::StaticRegisterNativesULeapMotionControllerComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionControllerComponent::StaticClass(),"GetAllHandActors",(Native)&ULeapMotionControllerComponent::execGetAllHandActors);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionControllerComponent::StaticClass(),"GetAllHandIds",(Native)&ULeapMotionControllerComponent::execGetAllHandIds);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionControllerComponent::StaticClass(),"GetHandActor",(Native)&ULeapMotionControllerComponent::execGetHandActor);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionControllerComponent::StaticClass(),"GetOldestLeftOrRightHandActor",(Native)&ULeapMotionControllerComponent::execGetOldestLeftOrRightHandActor);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionControllerComponent::StaticClass(),"UseHmdMode",(Native)&ULeapMotionControllerComponent::execUseHmdMode);
	}
	IMPLEMENT_CLASS(ULeapMotionControllerComponent, 3525718824);
	void ULeapMotionFunctionLibrary::StaticRegisterNativesULeapMotionFunctionLibrary()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionFunctionLibrary::StaticClass(),"GetAllHandsIds",(Native)&ULeapMotionFunctionLibrary::execGetAllHandsIds);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionFunctionLibrary::StaticClass(),"GetBonePostionAndOrientation",(Native)&ULeapMotionFunctionLibrary::execGetBonePostionAndOrientation);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionFunctionLibrary::StaticClass(),"GetBoneWidthAndLength",(Native)&ULeapMotionFunctionLibrary::execGetBoneWidthAndLength);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionFunctionLibrary::StaticClass(),"GetGrabStrength",(Native)&ULeapMotionFunctionLibrary::execGetGrabStrength);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionFunctionLibrary::StaticClass(),"GetOldestLeftOrRightHandId",(Native)&ULeapMotionFunctionLibrary::execGetOldestLeftOrRightHandId);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionFunctionLibrary::StaticClass(),"GetPinchStrength",(Native)&ULeapMotionFunctionLibrary::execGetPinchStrength);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionFunctionLibrary::StaticClass(),"IsConnected",(Native)&ULeapMotionFunctionLibrary::execIsConnected);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionFunctionLibrary::StaticClass(),"SetHmdPolicy",(Native)&ULeapMotionFunctionLibrary::execSetHmdPolicy);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionFunctionLibrary::StaticClass(),"SetImagePolicy",(Native)&ULeapMotionFunctionLibrary::execSetImagePolicy);
	}
	IMPLEMENT_CLASS(ULeapMotionFunctionLibrary, 2451298322);
	void ALeapMotionHandActor::StaticRegisterNativesALeapMotionHandActor()
	{
		FNativeFunctionRegistrar::RegisterFunction(ALeapMotionHandActor::StaticClass(),"GetBoneActor",(Native)&ALeapMotionHandActor::execGetBoneActor);
		FNativeFunctionRegistrar::RegisterFunction(ALeapMotionHandActor::StaticClass(),"GetParentingControllerComponent",(Native)&ALeapMotionHandActor::execGetParentingControllerComponent);
	}
	IMPLEMENT_CLASS(ALeapMotionHandActor, 3964899124);
	void ULeapMotionImageComponent::AttachDisplaySurface()
	{
		ProcessEvent(FindFunctionChecked(LEAPMOTIONCONTROLLER_AttachDisplaySurface),NULL);
	}
	void ULeapMotionImageComponent::StaticRegisterNativesULeapMotionImageComponent()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionImageComponent::StaticClass(),"AttachDisplaySurface",(Native)&ULeapMotionImageComponent::execAttachDisplaySurface);
		FNativeFunctionRegistrar::RegisterFunction(ULeapMotionImageComponent::StaticClass(),"UpdateImageTexture",(Native)&ULeapMotionImageComponent::execUpdateImageTexture);
	}
	IMPLEMENT_CLASS(ULeapMotionImageComponent, 2975333696);
FName LEAPMOTIONCONTROLLER_AttachDisplaySurface = FName(TEXT("AttachDisplaySurface"));
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject();
	ENGINE_API class UClass* Z_Construct_UClass_AActor();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMeshComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UPrimitiveComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USceneComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialInterface_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMesh_NoRegister();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	ENGINE_API class UClass* Z_Construct_UClass_UBlueprintFunctionLibrary();
	ENGINE_API class UClass* Z_Construct_UClass_UActorComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UMaterialInstanceDynamic_NoRegister();

	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UDelegateFunction_LeapMotionController_LMHandUpdatedDelegate__DelegateSignature();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UDelegateFunction_LeapMotionController_LMHandRemovedDelegate__DelegateSignature();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UDelegateFunction_LeapMotionController_LMHandAddedDelegate__DelegateSignature();
	LEAPMOTIONCONTROLLER_API class UEnum* Z_Construct_UEnum_LeapMotionController_ELeapBone();
	LEAPMOTIONCONTROLLER_API class UEnum* Z_Construct_UEnum_LeapMotionController_ELeapSide();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ULeapMotionTypes_NoRegister();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ULeapMotionTypes();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_GetHandActor();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_GetParentingControllerComponent();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_Init();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForArm();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForFinger();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForPalm();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ALeapMotionBoneActor_NoRegister();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ALeapMotionBoneActor();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ALeapMotionControllerActor_NoRegister();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ALeapMotionControllerActor();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionControllerComponent_GetAllHandActors();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionControllerComponent_GetAllHandIds();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionControllerComponent_GetHandActor();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionControllerComponent_GetOldestLeftOrRightHandActor();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionControllerComponent_UseHmdMode();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ULeapMotionControllerComponent_NoRegister();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ULeapMotionControllerComponent();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetAllHandsIds();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetBonePostionAndOrientation();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetBoneWidthAndLength();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetGrabStrength();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetOldestLeftOrRightHandId();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetPinchStrength();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_IsConnected();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_SetHmdPolicy();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_SetImagePolicy();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ULeapMotionFunctionLibrary_NoRegister();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ULeapMotionFunctionLibrary();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ALeapMotionHandActor_GetBoneActor();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ALeapMotionHandActor_GetParentingControllerComponent();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ALeapMotionHandActor_NoRegister();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ALeapMotionHandActor();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionImageComponent_AttachDisplaySurface();
	LEAPMOTIONCONTROLLER_API class UFunction* Z_Construct_UFunction_ULeapMotionImageComponent_UpdateImageTexture();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ULeapMotionImageComponent_NoRegister();
	LEAPMOTIONCONTROLLER_API class UClass* Z_Construct_UClass_ULeapMotionImageComponent();
	LEAPMOTIONCONTROLLER_API class UPackage* Z_Construct_UPackage_LeapMotionController();
	UFunction* Z_Construct_UDelegateFunction_LeapMotionController_LMHandUpdatedDelegate__DelegateSignature()
	{
		struct _Script_LeapMotionController_eventLMHandUpdatedDelegate_Parms
		{
			int32 HandId;
			float DeltaSeconds;
		};
		UObject* Outer=Z_Construct_UPackage_LeapMotionController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LMHandUpdatedDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_LeapMotionController_eventLMHandUpdatedDelegate_Parms));
			UProperty* NewProp_DeltaSeconds = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeltaSeconds"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DeltaSeconds, _Script_LeapMotionController_eventLMHandUpdatedDelegate_Parms), 0x0000000000000080);
			UProperty* NewProp_HandId = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HandId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(HandId, _Script_LeapMotionController_eventLMHandUpdatedDelegate_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionTypes.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_LeapMotionController_LMHandRemovedDelegate__DelegateSignature()
	{
		struct _Script_LeapMotionController_eventLMHandRemovedDelegate_Parms
		{
			int32 HandId;
		};
		UObject* Outer=Z_Construct_UPackage_LeapMotionController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LMHandRemovedDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_LeapMotionController_eventLMHandRemovedDelegate_Parms));
			UProperty* NewProp_HandId = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HandId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(HandId, _Script_LeapMotionController_eventLMHandRemovedDelegate_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionTypes.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UDelegateFunction_LeapMotionController_LMHandAddedDelegate__DelegateSignature()
	{
		struct _Script_LeapMotionController_eventLMHandAddedDelegate_Parms
		{
			int32 HandId;
		};
		UObject* Outer=Z_Construct_UPackage_LeapMotionController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LMHandAddedDelegate__DelegateSignature"), RF_Public|RF_Transient|RF_Native) UDelegateFunction(FObjectInitializer(), NULL, 0x00130000, 65535, sizeof(_Script_LeapMotionController_eventLMHandAddedDelegate_Parms));
			UProperty* NewProp_HandId = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HandId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(HandId, _Script_LeapMotionController_eventLMHandAddedDelegate_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionTypes.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Delegate types"));
#endif
		}
		return ReturnFunction;
	}
	UEnum* Z_Construct_UEnum_LeapMotionController_ELeapBone()
	{
		UPackage* Outer=Z_Construct_UPackage_LeapMotionController();
		static UEnum* ReturnEnum = NULL;
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ELeapBone"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Forearm")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Palm")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::ThumbBase")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::ThumbMiddle")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::ThumbTip")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger1Base")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger1Middle")), 6));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger1Tip")), 7));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger2Base")), 8));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger2Middle")), 9));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger2Tip")), 10));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger3Base")), 11));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger3Middle")), 12));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger3Tip")), 13));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger4Base")), 14));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger4Middle")), 15));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::Finger4Tip")), 16));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapBone::ELeapBone_MAX")), 17));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("Finger1Base.ToolTip"), TEXT("The anatomical index finger proximal phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Finger1Middle.ToolTip"), TEXT("The anatomical index finger intermediate phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Finger1Tip.ToolTip"), TEXT("The anatomical index finger distal phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Finger2Base.ToolTip"), TEXT("The anatomical middle finger proximal phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Finger2Middle.ToolTip"), TEXT("The anatomical middle finger intermediate phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Finger2Tip.ToolTip"), TEXT("The anatomical middle finger distal phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Finger3Base.ToolTip"), TEXT("The anatomical ring finger proximal phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Finger3Middle.ToolTip"), TEXT("The anatomical ring finger intermediate phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Finger3Tip.ToolTip"), TEXT("The anatomical ring finger distal phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Finger4Base.ToolTip"), TEXT("The anatomical pinky finger proximal phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Finger4Middle.ToolTip"), TEXT("The anatomical pink finger intermediate phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Finger4Tip.ToolTip"), TEXT("The anatomical pinky finger distal phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("Forearm.ToolTip"), TEXT("The arm bone from elbow to wrist."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("Palm.ToolTip"), TEXT("The central portion of the hand, excluding fingers."));
			MetaData->SetValue(ReturnEnum, TEXT("ThumbBase.ToolTip"), TEXT("The anatomical thumb metacarpal."));
			MetaData->SetValue(ReturnEnum, TEXT("ThumbMiddle.ToolTip"), TEXT("The anatomical thumb proximal phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("ThumbTip.ToolTip"), TEXT("The anatomical thumb distal phalanx."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Enum to define a hand's bone. This includes finger bones, palm, and arm."));
#endif
		}
		return ReturnEnum;
	}
	UEnum* Z_Construct_UEnum_LeapMotionController_ELeapSide()
	{
		UPackage* Outer=Z_Construct_UPackage_LeapMotionController();
		static UEnum* ReturnEnum = NULL;
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ELeapSide"), RF_Public|RF_Transient|RF_Native) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapSide::Left")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapSide::Right")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ELeapSide::ELeapSide_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("Left.ToolTip"), TEXT("Port"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("Right.ToolTip"), TEXT("Starboard"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("The names for designating the hands."));
#endif
		}
		return ReturnEnum;
	}
	UClass* Z_Construct_UClass_ULeapMotionTypes_NoRegister()
	{
		return ULeapMotionTypes::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapMotionTypes()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage_LeapMotionController();
			OuterClass = ULeapMotionTypes::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20000080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapMotionTypes.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionTypes.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Dummy class to get this file compiling, when delegates are declared above"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapMotionTypes(Z_Construct_UClass_ULeapMotionTypes, TEXT("ULeapMotionTypes"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapMotionTypes);
	UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_GetHandActor()
	{
		struct LeapMotionBoneActor_eventGetHandActor_Parms
		{
			ALeapMotionHandActor* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ALeapMotionBoneActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetHandActor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapMotionBoneActor_eventGetHandActor_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapMotionBoneActor_eventGetHandActor_Parms), 0x0000000000000580, Z_Construct_UClass_ALeapMotionHandActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the hand actor this bone belongs to.\n@returns the parent LeapMotionHandActor instance."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_GetParentingControllerComponent()
	{
		struct LeapMotionBoneActor_eventGetParentingControllerComponent_Parms
		{
			ULeapMotionControllerComponent* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ALeapMotionBoneActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetParentingControllerComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapMotionBoneActor_eventGetParentingControllerComponent_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapMotionBoneActor_eventGetParentingControllerComponent_Parms), 0x0000000000080588, Z_Construct_UClass_ULeapMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the controller component that created this bone and its parenting hand.\n@returns The parent LeapMotionControllerComponent."));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_Init()
	{
		struct LeapMotionBoneActor_eventInit_Parms
		{
			TEnumAsByte<ELeapBone> LeapBone;
			float Scale;
			float Width;
			float Length;
			bool ShowCollider;
			bool ShowMesh;
		};
		UObject* Outer=Z_Construct_UClass_ALeapMotionBoneActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Init"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(LeapMotionBoneActor_eventInit_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ShowMesh, LeapMotionBoneActor_eventInit_Parms, bool);
			UProperty* NewProp_ShowMesh = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ShowMesh"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ShowMesh, LeapMotionBoneActor_eventInit_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(ShowMesh, LeapMotionBoneActor_eventInit_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ShowCollider, LeapMotionBoneActor_eventInit_Parms, bool);
			UProperty* NewProp_ShowCollider = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ShowCollider"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ShowCollider, LeapMotionBoneActor_eventInit_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(ShowCollider, LeapMotionBoneActor_eventInit_Parms), sizeof(bool), true);
			UProperty* NewProp_Length = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Length"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Length, LeapMotionBoneActor_eventInit_Parms), 0x0000000000000080);
			UProperty* NewProp_Width = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Width"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Width, LeapMotionBoneActor_eventInit_Parms), 0x0000000000000080);
			UProperty* NewProp_Scale = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Scale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Scale, LeapMotionBoneActor_eventInit_Parms), 0x0000000000000080);
			UProperty* NewProp_LeapBone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LeapBone"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LeapBone, LeapMotionBoneActor_eventInit_Parms), 0x0000000000000080, Z_Construct_UEnum_LeapMotionController_ELeapBone());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Called to initialize the size and display properties of a bone based on\nthe current hand settings.\n\nSubclasses of LeapMotionBoneActor can implement this function to override\nthe default behavior.\n\n@param LeapBone The name of the current bone.\n@param Scale The relative scale for this bone.\n@param Width The width of this bone.\n@param Length The length of this bone.\n@param ShowCollider Whether to render the colliders.\n@param ShowMesh Whether to render the mesh for this bone."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForArm()
	{
		UObject* Outer=Z_Construct_UClass_ALeapMotionBoneActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMeshForArm"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04080400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Uses the default arm mesh."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForFinger()
	{
		UObject* Outer=Z_Construct_UClass_ALeapMotionBoneActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMeshForFinger"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04080400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Uses the default finger mesh."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForPalm()
	{
		UObject* Outer=Z_Construct_UClass_ALeapMotionBoneActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetMeshForPalm"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04080400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Uses the default palm mesh."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ALeapMotionBoneActor_NoRegister()
	{
		return ALeapMotionBoneActor::StaticClass();
	}
	UClass* Z_Construct_UClass_ALeapMotionBoneActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_LeapMotionController();
			OuterClass = ALeapMotionBoneActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_ALeapMotionBoneActor_GetHandActor());
				OuterClass->LinkChild(Z_Construct_UFunction_ALeapMotionBoneActor_GetParentingControllerComponent());
				OuterClass->LinkChild(Z_Construct_UFunction_ALeapMotionBoneActor_Init());
				OuterClass->LinkChild(Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForArm());
				OuterClass->LinkChild(Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForFinger());
				OuterClass->LinkChild(Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForPalm());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_StaticMeshComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StaticMeshComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(StaticMeshComponent, ALeapMotionBoneActor), 0x000000000008000d, Z_Construct_UClass_UStaticMeshComponent_NoRegister());
				UProperty* NewProp_PrimitiveComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PrimitiveComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PrimitiveComponent, ALeapMotionBoneActor), 0x000000000008000d, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShowMesh, ALeapMotionBoneActor, bool);
				UProperty* NewProp_bShowMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShowMesh"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShowMesh, ALeapMotionBoneActor), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bShowMesh, ALeapMotionBoneActor), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShowCollider, ALeapMotionBoneActor, bool);
				UProperty* NewProp_bShowCollider = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShowCollider"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShowCollider, ALeapMotionBoneActor), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bShowCollider, ALeapMotionBoneActor), sizeof(bool), true);
				UProperty* NewProp_LeapBoneType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LeapBoneType"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LeapBoneType, ALeapMotionBoneActor), 0x0000000000020015, Z_Construct_UEnum_LeapMotionController_ELeapBone());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ALeapMotionBoneActor_GetHandActor()); // 2663771838
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ALeapMotionBoneActor_GetParentingControllerComponent()); // 20948425
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ALeapMotionBoneActor_Init()); // 2547559861
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForArm()); // 1517762648
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForFinger()); // 2069126902
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ALeapMotionBoneActor_SetMeshForPalm()); // 1717213983
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("LeapMotion"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapMotionBoneActor.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Represents a single part of a hand tracked by the Leap Motion Controller.\n\nBone Actors are created automatically by a LeapMotionHandActor instance. You can\nextended this class to replace or augment the default behavior.\n\nBone actors contain the position and orientation information. These attributes\nare relative to the parent LeapMotionHandActor, but note that by default a\nHand actor has the same position and orientation as its parent\nLeapMotionControllerComponent object."));
				MetaData->SetValue(NewProp_StaticMeshComponent, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_StaticMeshComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_StaticMeshComponent, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
				MetaData->SetValue(NewProp_StaticMeshComponent, TEXT("ToolTip"), TEXT("The Static mesh for rendering the hand bone."));
				MetaData->SetValue(NewProp_PrimitiveComponent, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_PrimitiveComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_PrimitiveComponent, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
				MetaData->SetValue(NewProp_PrimitiveComponent, TEXT("ToolTip"), TEXT("The Unreal Primitive component used for collisions with the scene objects."));
				MetaData->SetValue(NewProp_bShowMesh, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bShowMesh, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
				MetaData->SetValue(NewProp_bShowMesh, TEXT("ToolTip"), TEXT("Whether to render the hand bone's mesh in game."));
				MetaData->SetValue(NewProp_bShowCollider, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bShowCollider, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
				MetaData->SetValue(NewProp_bShowCollider, TEXT("ToolTip"), TEXT("Whether to visualize hand bone's colliding shape in game."));
				MetaData->SetValue(NewProp_LeapBoneType, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_LeapBoneType, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionBoneActor.h"));
				MetaData->SetValue(NewProp_LeapBoneType, TEXT("ToolTip"), TEXT("The name of this bone."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ALeapMotionBoneActor(Z_Construct_UClass_ALeapMotionBoneActor, TEXT("ALeapMotionBoneActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ALeapMotionBoneActor);
	UClass* Z_Construct_UClass_ALeapMotionControllerActor_NoRegister()
	{
		return ALeapMotionControllerActor::StaticClass();
	}
	UClass* Z_Construct_UClass_ALeapMotionControllerActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_LeapMotionController();
			OuterClass = ALeapMotionControllerActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_LeapMotionImageComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LeapMotionImageComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(LeapMotionImageComponent, ALeapMotionControllerActor), 0x00000000000a001d, Z_Construct_UClass_ULeapMotionImageComponent_NoRegister());
				UProperty* NewProp_LeapMotionControllerComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LeapMotionControllerComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(LeapMotionControllerComponent, ALeapMotionControllerActor), 0x00000000000a001d, Z_Construct_UClass_ULeapMotionControllerComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("LeapMotion"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapMotionControllerActor.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("An Unreal Actor instance that allows you to drop a set of 3D hands anywhere in a level.\n\nContains a LeapMotionControllerComponent instance which does all of the work."));
				MetaData->SetValue(NewProp_LeapMotionImageComponent, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_LeapMotionImageComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_LeapMotionImageComponent, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerActor.h"));
				MetaData->SetValue(NewProp_LeapMotionImageComponent, TEXT("ToolTip"), TEXT("An Unreal Component instance."));
				MetaData->SetValue(NewProp_LeapMotionControllerComponent, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_LeapMotionControllerComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_LeapMotionControllerComponent, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerActor.h"));
				MetaData->SetValue(NewProp_LeapMotionControllerComponent, TEXT("ToolTip"), TEXT("An Unreal Component instance."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ALeapMotionControllerActor(Z_Construct_UClass_ALeapMotionControllerActor, TEXT("ALeapMotionControllerActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ALeapMotionControllerActor);
	UFunction* Z_Construct_UFunction_ULeapMotionControllerComponent_GetAllHandActors()
	{
		struct LeapMotionControllerComponent_eventGetAllHandActors_Parms
		{
			TArray<ALeapMotionHandActor*> OutHandActors;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAllHandActors"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54420401, 65535, sizeof(LeapMotionControllerComponent_eventGetAllHandActors_Parms));
			UProperty* NewProp_OutHandActors = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHandActors"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(OutHandActors, LeapMotionControllerComponent_eventGetAllHandActors_Parms), 0x0000000000000180);
			UProperty* NewProp_OutHandActors_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutHandActors, TEXT("OutHandActors"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_ALeapMotionHandActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets all active hands actors.\n@param OutHandActors Output array which is filled with existing hand actors."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionControllerComponent_GetAllHandIds()
	{
		struct LeapMotionControllerComponent_eventGetAllHandIds_Parms
		{
			TArray<int32> OutHandIds;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAllHandIds"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54420401, 65535, sizeof(LeapMotionControllerComponent_eventGetAllHandIds_Parms));
			UProperty* NewProp_OutHandIds = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHandIds"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(OutHandIds, LeapMotionControllerComponent_eventGetAllHandIds_Parms), 0x0000000000000180);
			UProperty* NewProp_OutHandIds_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutHandIds, TEXT("OutHandIds"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets all active hands ids.\n@param OutHandIds Output array which is filled with the ids of existing hands."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionControllerComponent_GetHandActor()
	{
		struct LeapMotionControllerComponent_eventGetHandActor_Parms
		{
			int32 HandId;
			ALeapMotionHandActor* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetHandActor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapMotionControllerComponent_eventGetHandActor_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapMotionControllerComponent_eventGetHandActor_Parms), 0x0000000000000580, Z_Construct_UClass_ALeapMotionHandActor_NoRegister());
			UProperty* NewProp_HandId = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HandId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(HandId, LeapMotionControllerComponent_eventGetHandActor_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the hand actor instance for the specified hand ID.\n@param HandId The Leap Motion ID for the hand of interest.\n@returns     A pointer to the Actor object if the hand ID is active, nullptr otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionControllerComponent_GetOldestLeftOrRightHandActor()
	{
		struct LeapMotionControllerComponent_eventGetOldestLeftOrRightHandActor_Parms
		{
			TEnumAsByte<ELeapSide> LeapSide;
			ALeapMotionHandActor* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetOldestLeftOrRightHandActor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapMotionControllerComponent_eventGetOldestLeftOrRightHandActor_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapMotionControllerComponent_eventGetOldestLeftOrRightHandActor_Parms), 0x0000000000000580, Z_Construct_UClass_ALeapMotionHandActor_NoRegister());
			UProperty* NewProp_LeapSide = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LeapSide"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LeapSide, LeapMotionControllerComponent_eventGetOldestLeftOrRightHandActor_Parms), 0x0000000000000080, Z_Construct_UEnum_LeapMotionController_ELeapSide());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the oldest left- or right-hand actor, if one exists, nullptr otherwise.\n\nIf more than one left or right hand is being tracked, this function returns\nthe one that has been tracked the longest.\n@param LeapSide      Are we looking for left or right-sided hands?\n@return                      Pointer to oldest hand actor if one is found, nullptr otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionControllerComponent_UseHmdMode()
	{
		struct LeapMotionControllerComponent_eventUseHmdMode_Parms
		{
			bool EnableOrDisable;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionControllerComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UseHmdMode"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapMotionControllerComponent_eventUseHmdMode_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableOrDisable, LeapMotionControllerComponent_eventUseHmdMode_Parms, bool);
			UProperty* NewProp_EnableOrDisable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EnableOrDisable"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableOrDisable, LeapMotionControllerComponent_eventUseHmdMode_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(EnableOrDisable, LeapMotionControllerComponent_eventUseHmdMode_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets the controller as when attached to an HMD, or in the standard desktop mode\nPuts the Leap Motion controller and this component into (or out of) HMD mode.\nThis sets the Leap Motion software to use the Optimize for HMD policy.\nIt also changes the transform of Leap Motion to Unreal coordinates so that the\nhands are projected in front of the component position rather than above it.\n\n@param EnableOrDisable Set to true to enable HMD mode."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapMotionControllerComponent_NoRegister()
	{
		return ULeapMotionControllerComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapMotionControllerComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage_LeapMotionController();
			OuterClass = ULeapMotionControllerComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionControllerComponent_GetAllHandActors());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionControllerComponent_GetAllHandIds());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionControllerComponent_GetHandActor());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionControllerComponent_GetOldestLeftOrRightHandActor());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionControllerComponent_UseHmdMode());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Material = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Material"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(Material, ULeapMotionControllerComponent), 0x0000000000000005, Z_Construct_UClass_UMaterialInterface_NoRegister());
				UProperty* NewProp_ArmMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ArmMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ArmMesh, ULeapMotionControllerComponent), 0x0000000000000005, Z_Construct_UClass_UStaticMesh_NoRegister());
				UProperty* NewProp_PalmMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PalmMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PalmMesh, ULeapMotionControllerComponent), 0x0000000000000005, Z_Construct_UClass_UStaticMesh_NoRegister());
				UProperty* NewProp_FingerMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FingerMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(FingerMesh, ULeapMotionControllerComponent), 0x0000000000000005, Z_Construct_UClass_UStaticMesh_NoRegister());
				UProperty* NewProp_OnHandUpdated = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnHandUpdated"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnHandUpdated, ULeapMotionControllerComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_LeapMotionController_LMHandUpdatedDelegate__DelegateSignature());
				UProperty* NewProp_OnHandRemoved = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnHandRemoved"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnHandRemoved, ULeapMotionControllerComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_LeapMotionController_LMHandRemovedDelegate__DelegateSignature());
				UProperty* NewProp_OnHandAdded = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnHandAdded"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnHandAdded, ULeapMotionControllerComponent), 0x0000000010080000, Z_Construct_UDelegateFunction_LeapMotionController_LMHandAddedDelegate__DelegateSignature());
				UProperty* NewProp_BoneBlueprint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BoneBlueprint"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(BoneBlueprint, ULeapMotionControllerComponent), 0x0004000000000005, Z_Construct_UClass_ALeapMotionBoneActor_NoRegister());
				UProperty* NewProp_HandBlueprint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HandBlueprint"), RF_Public|RF_Transient|RF_Native) UClassProperty(CPP_PROPERTY_BASE(HandBlueprint, ULeapMotionControllerComponent), 0x0004000000000005, Z_Construct_UClass_ALeapMotionHandActor_NoRegister());
				UProperty* NewProp_OffsetFromHMDToLeapDevice = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OffsetFromHMDToLeapDevice"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OffsetFromHMDToLeapDevice, ULeapMotionControllerComponent), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAutoAttachToPlayerCamera, ULeapMotionControllerComponent, bool);
				UProperty* NewProp_bAutoAttachToPlayerCamera = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAutoAttachToPlayerCamera"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAutoAttachToPlayerCamera, ULeapMotionControllerComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bAutoAttachToPlayerCamera, ULeapMotionControllerComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHmdMode, ULeapMotionControllerComponent, bool);
				UProperty* NewProp_bHmdMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bHmdMode"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHmdMode, ULeapMotionControllerComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bHmdMode, ULeapMotionControllerComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShowArm, ULeapMotionControllerComponent, bool);
				UProperty* NewProp_bShowArm = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShowArm"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShowArm, ULeapMotionControllerComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bShowArm, ULeapMotionControllerComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShowMesh, ULeapMotionControllerComponent, bool);
				UProperty* NewProp_bShowMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShowMesh"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShowMesh, ULeapMotionControllerComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bShowMesh, ULeapMotionControllerComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShowCollider, ULeapMotionControllerComponent, bool);
				UProperty* NewProp_bShowCollider = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShowCollider"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShowCollider, ULeapMotionControllerComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bShowCollider, ULeapMotionControllerComponent), sizeof(bool), true);
				UProperty* NewProp_ScaleForHmdMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleForHmdMode"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(ScaleForHmdMode, ULeapMotionControllerComponent), 0x0000000000000005);
				UProperty* NewProp_Scale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Scale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Scale, ULeapMotionControllerComponent), 0x0000000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionControllerComponent_GetAllHandActors()); // 3300990108
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionControllerComponent_GetAllHandIds()); // 2070728407
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionControllerComponent_GetHandActor()); // 2628533509
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionControllerComponent_GetOldestLeftOrRightHandActor()); // 381028738
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionControllerComponent_UseHmdMode()); // 426499370
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("LeapMotion"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Trigger PhysicsVolume ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapMotionControllerComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Add this component to an actor and place the actor in the world to automatically create hand actors\nas tracked by Leap Motion controller. Move the location of the controller, or attach it to another actor,\nand the hands will follow the controller's transform. Set the scale parameter, rather then transforms's scale,\nto affect the scale of the created hand objects."));
				MetaData->SetValue(NewProp_Material, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_Material, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_Material, TEXT("ToolTip"), TEXT("Material used by the default hand implementation."));
				MetaData->SetValue(NewProp_ArmMesh, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_ArmMesh, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_ArmMesh, TEXT("ToolTip"), TEXT("Arm model mesh used by the default hand implementation."));
				MetaData->SetValue(NewProp_PalmMesh, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_PalmMesh, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_PalmMesh, TEXT("ToolTip"), TEXT("Palm model mesh used by the default hand implementation."));
				MetaData->SetValue(NewProp_FingerMesh, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_FingerMesh, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_FingerMesh, TEXT("ToolTip"), TEXT("Finger model mesh used by the default hand implementation."));
				MetaData->SetValue(NewProp_OnHandUpdated, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_OnHandUpdated, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_OnHandUpdated, TEXT("ToolTip"), TEXT("Delegate triggered once per frame update for each hand."));
				MetaData->SetValue(NewProp_OnHandRemoved, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_OnHandRemoved, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_OnHandRemoved, TEXT("ToolTip"), TEXT("Delegate triggered when a hand lost by the Leap Motion device."));
				MetaData->SetValue(NewProp_OnHandAdded, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_OnHandAdded, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_OnHandAdded, TEXT("ToolTip"), TEXT("Delegate triggered when a new hand is spotted by the Leap Motion device."));
				MetaData->SetValue(NewProp_BoneBlueprint, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_BoneBlueprint, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_BoneBlueprint, TEXT("ToolTip"), TEXT("Optional blueprint used to spawn each individual finger bone. When none is specified ALeapMotionHandBoneActor is created"));
				MetaData->SetValue(NewProp_HandBlueprint, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_HandBlueprint, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_HandBlueprint, TEXT("ToolTip"), TEXT("Optional blueprint used to spawn each hand. When none is specified ALeapMotionHandActor is created."));
				MetaData->SetValue(NewProp_OffsetFromHMDToLeapDevice, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_OffsetFromHMDToLeapDevice, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_OffsetFromHMDToLeapDevice, TEXT("ToolTip"), TEXT("Placement of Leap Device in relation to HMD position."));
				MetaData->SetValue(NewProp_bAutoAttachToPlayerCamera, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bAutoAttachToPlayerCamera, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bAutoAttachToPlayerCamera, TEXT("ToolTip"), TEXT("Whether to automatically attach this controller to player camera, both in desktop & VR modes."));
				MetaData->SetValue(NewProp_bHmdMode, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bHmdMode, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bHmdMode, TEXT("ToolTip"), TEXT("Whether to transform the tracking data as appropriate for a Leap Motion device\nattached to an HMD."));
				MetaData->SetValue(NewProp_bShowArm, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bShowArm, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bShowArm, TEXT("ToolTip"), TEXT("Whether to render the hand's arm"));
				MetaData->SetValue(NewProp_bShowMesh, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bShowMesh, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bShowMesh, TEXT("ToolTip"), TEXT("Whether to render the hand's mesh in game"));
				MetaData->SetValue(NewProp_bShowCollider, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bShowCollider, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_bShowCollider, TEXT("ToolTip"), TEXT("Whether to render the hand's colliding shape in game"));
				MetaData->SetValue(NewProp_ScaleForHmdMode, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_ScaleForHmdMode, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_ScaleForHmdMode, TEXT("ToolTip"), TEXT("The scale of hands, when in HMD mode, relative to real-world size. This ignores actor's transform's scale"));
				MetaData->SetValue(NewProp_Scale, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_Scale, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionControllerComponent.h"));
				MetaData->SetValue(NewProp_Scale, TEXT("ToolTip"), TEXT("The scale of hands, relative to real-world size. This ignores actor's transform's scale"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapMotionControllerComponent(Z_Construct_UClass_ULeapMotionControllerComponent, TEXT("ULeapMotionControllerComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapMotionControllerComponent);
	UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetAllHandsIds()
	{
		struct LeapMotionFunctionLibrary_eventGetAllHandsIds_Parms
		{
			TArray<int32> OutAllHandIds;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetAllHandsIds"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14422401, 65535, sizeof(LeapMotionFunctionLibrary_eventGetAllHandsIds_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapMotionFunctionLibrary_eventGetAllHandsIds_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapMotionFunctionLibrary_eventGetAllHandsIds_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapMotionFunctionLibrary_eventGetAllHandsIds_Parms), sizeof(bool), true);
			UProperty* NewProp_OutAllHandIds = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutAllHandIds"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(OutAllHandIds, LeapMotionFunctionLibrary_eventGetAllHandsIds_Parms), 0x0000000000000180);
			UProperty* NewProp_OutAllHandIds_Inner = new(EC_InternalUseOnlyConstructor, NewProp_OutAllHandIds, TEXT("OutAllHandIds"), RF_Public|RF_Transient|RF_Native) UIntProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns list of IDs of all hands tracked by the device.\n@param OutAllHandIds         Output array which is filled with all the tracked hand IDs.\n@returns                                     True, if the device is connected."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetBonePostionAndOrientation()
	{
		struct LeapMotionFunctionLibrary_eventGetBonePostionAndOrientation_Parms
		{
			int32 HandId;
			TEnumAsByte<ELeapBone> LeapBone;
			FVector OutPosition;
			FRotator OutOrientation;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBonePostionAndOrientation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14C22401, 65535, sizeof(LeapMotionFunctionLibrary_eventGetBonePostionAndOrientation_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapMotionFunctionLibrary_eventGetBonePostionAndOrientation_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapMotionFunctionLibrary_eventGetBonePostionAndOrientation_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapMotionFunctionLibrary_eventGetBonePostionAndOrientation_Parms), sizeof(bool), true);
			UProperty* NewProp_OutOrientation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutOrientation"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutOrientation, LeapMotionFunctionLibrary_eventGetBonePostionAndOrientation_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_OutPosition = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutPosition"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(OutPosition, LeapMotionFunctionLibrary_eventGetBonePostionAndOrientation_Parms), 0x0000000000000180, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_LeapBone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LeapBone"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LeapBone, LeapMotionFunctionLibrary_eventGetBonePostionAndOrientation_Parms), 0x0000000000000080, Z_Construct_UEnum_LeapMotionController_ELeapBone());
			UProperty* NewProp_HandId = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HandId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(HandId, LeapMotionFunctionLibrary_eventGetBonePostionAndOrientation_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the position and orientation of the specified bone of the specified hand.\nData returned by this function is relative to the Unreal Engine origin rather than\na particular LeapMotionControllerComponent or LeapMotionHandActor instance.\nGet the properties of a LeapMotionBoneActor instance to get the data\nrelative to that actor's parent hand actor and controller component. In this\ncase, use the standard Unreal Actor location and rotation properties.\n\n@param HandId                        The id of the hand of interest.\n@param LeapBone                      The bone of interest.\n@param OutPosition           An FVector set to the relative position of the hand,\n                                                     or a zero vector if a hand with the specified id does not exist.\n@param OutOrientation        An FRotator set to the relative orientation of\n                                                     the specified bone, or a zero rotation if a hand\n                                                     with the specified id does not exist.\n@returns                                     True, if the hand with the specified id exists, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetBoneWidthAndLength()
	{
		struct LeapMotionFunctionLibrary_eventGetBoneWidthAndLength_Parms
		{
			int32 HandId;
			TEnumAsByte<ELeapBone> LeapBone;
			float OutWidth;
			float OutLength;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBoneWidthAndLength"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14422401, 65535, sizeof(LeapMotionFunctionLibrary_eventGetBoneWidthAndLength_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapMotionFunctionLibrary_eventGetBoneWidthAndLength_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapMotionFunctionLibrary_eventGetBoneWidthAndLength_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapMotionFunctionLibrary_eventGetBoneWidthAndLength_Parms), sizeof(bool), true);
			UProperty* NewProp_OutLength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutLength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OutLength, LeapMotionFunctionLibrary_eventGetBoneWidthAndLength_Parms), 0x0000000000000180);
			UProperty* NewProp_OutWidth = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutWidth"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(OutWidth, LeapMotionFunctionLibrary_eventGetBoneWidthAndLength_Parms), 0x0000000000000180);
			UProperty* NewProp_LeapBone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LeapBone"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LeapBone, LeapMotionFunctionLibrary_eventGetBoneWidthAndLength_Parms), 0x0000000000000080, Z_Construct_UEnum_LeapMotionController_ELeapBone());
			UProperty* NewProp_HandId = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HandId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(HandId, LeapMotionFunctionLibrary_eventGetBoneWidthAndLength_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Gets the width and length of the specified bone of the specified hand.\n@param HandId                        The id of the hand of interest.\n@param LeapBone                      The bone of interest.\n@param OutWidth                      A float set to the bone's width (in centimeters).\n@param OutLength                     A float set to the bone's length (in centimeters).\n@returns                                     True, if the hand with the specified id exists, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetGrabStrength()
	{
		struct LeapMotionFunctionLibrary_eventGetGrabStrength_Parms
		{
			int32 HandId;
			float GrabStrength;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetGrabStrength"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14422401, 65535, sizeof(LeapMotionFunctionLibrary_eventGetGrabStrength_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapMotionFunctionLibrary_eventGetGrabStrength_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapMotionFunctionLibrary_eventGetGrabStrength_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapMotionFunctionLibrary_eventGetGrabStrength_Parms), sizeof(bool), true);
			UProperty* NewProp_GrabStrength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrabStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(GrabStrength, LeapMotionFunctionLibrary_eventGetGrabStrength_Parms), 0x0000000000000180);
			UProperty* NewProp_HandId = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HandId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(HandId, LeapMotionFunctionLibrary_eventGetGrabStrength_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The grab strength rating of the specified hand.\n\nGrab strength is a rating of how the hand's posture resembles a fist.\nA strength of 0 is close to an open, flat hand; a strength of 1 is close\nto a fist.\n@param HandId                        The id of the hand of interest.\n@param GrabStrength          A float set to the hand's grabbing strength as reported by Leap API.\n@returns                                     True, if the hand with the specified id exists, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetOldestLeftOrRightHandId()
	{
		struct LeapMotionFunctionLibrary_eventGetOldestLeftOrRightHandId_Parms
		{
			TEnumAsByte<ELeapSide> LeapSide;
			int32 OutHandId;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetOldestLeftOrRightHandId"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14422401, 65535, sizeof(LeapMotionFunctionLibrary_eventGetOldestLeftOrRightHandId_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapMotionFunctionLibrary_eventGetOldestLeftOrRightHandId_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapMotionFunctionLibrary_eventGetOldestLeftOrRightHandId_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapMotionFunctionLibrary_eventGetOldestLeftOrRightHandId_Parms), sizeof(bool), true);
			UProperty* NewProp_OutHandId = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OutHandId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(OutHandId, LeapMotionFunctionLibrary_eventGetOldestLeftOrRightHandId_Parms), 0x0000000000000180);
			UProperty* NewProp_LeapSide = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LeapSide"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LeapSide, LeapMotionFunctionLibrary_eventGetOldestLeftOrRightHandId_Parms), 0x0000000000000080, Z_Construct_UEnum_LeapMotionController_ELeapSide());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the oldest left- or right-hand actor, if one exists, nullptr otherwise.\n\nIf more than one left or right hand is being tracked, this function returns\nthe one that has been tracked the longest.\n@param LeapSide      Look for a left or a right hand.\n@param OutHandId     An integer set to the Leap Motion id of the oldest left\n                                     or right hand. If no hand is found, this is set to -1.\n@returns                     True if a hand of the specified type exists, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetPinchStrength()
	{
		struct LeapMotionFunctionLibrary_eventGetPinchStrength_Parms
		{
			int32 HandId;
			float PinchStrength;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPinchStrength"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14422401, 65535, sizeof(LeapMotionFunctionLibrary_eventGetPinchStrength_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapMotionFunctionLibrary_eventGetPinchStrength_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapMotionFunctionLibrary_eventGetPinchStrength_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapMotionFunctionLibrary_eventGetPinchStrength_Parms), sizeof(bool), true);
			UProperty* NewProp_PinchStrength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PinchStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PinchStrength, LeapMotionFunctionLibrary_eventGetPinchStrength_Parms), 0x0000000000000180);
			UProperty* NewProp_HandId = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HandId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(HandId, LeapMotionFunctionLibrary_eventGetPinchStrength_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The pinch strength rating of the specified hand.\n\nPinch strength is a rating of whether the hand is in a pinching posture.\nPinch strength starts at 0 and increases to 1 as any finger tip approaches\nthe tip of the thumb. Note that pinch and grab strength are not independent.\nA grabbing hand will generally have a non-zero pinch strength as well.\n\n@param HandId                        The id of the hand of interest.\n@param PinchStrength         A float set to the hand's pinch strength as reported by Leap API\n@returns                                     True, if the hand with the specified id exists, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_IsConnected()
	{
		struct LeapMotionFunctionLibrary_eventIsConnected_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsConnected"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x14022401, 65535, sizeof(LeapMotionFunctionLibrary_eventIsConnected_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapMotionFunctionLibrary_eventIsConnected_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapMotionFunctionLibrary_eventIsConnected_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapMotionFunctionLibrary_eventIsConnected_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Checks whether a Leap Motion controller is connected.\n@returns                     True if controller is connected, false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_SetHmdPolicy()
	{
		struct LeapMotionFunctionLibrary_eventSetHmdPolicy_Parms
		{
			bool UseHmdPolicy;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetHmdPolicy"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04022401, 65535, sizeof(LeapMotionFunctionLibrary_eventSetHmdPolicy_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapMotionFunctionLibrary_eventSetHmdPolicy_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapMotionFunctionLibrary_eventSetHmdPolicy_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapMotionFunctionLibrary_eventSetHmdPolicy_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(UseHmdPolicy, LeapMotionFunctionLibrary_eventSetHmdPolicy_Parms, bool);
			UProperty* NewProp_UseHmdPolicy = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("UseHmdPolicy"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(UseHmdPolicy, LeapMotionFunctionLibrary_eventSetHmdPolicy_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(UseHmdPolicy, LeapMotionFunctionLibrary_eventSetHmdPolicy_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enables or disables the Leap Motion Controller policy that improves tracking for an\nHMD-mounted controller.\nNote that calling this function does not change the transforms of any\nLeapMotionControllerComponent instances that may exist.\n\n@param UseHmdPolicy          True to enable for HMD-mounted mode, false to disable.\n@returns                                     True if the device is connected."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionFunctionLibrary_SetImagePolicy()
	{
		struct LeapMotionFunctionLibrary_eventSetImagePolicy_Parms
		{
			bool UseImagePolicy;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapMotionFunctionLibrary();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetImagePolicy"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04022401, 65535, sizeof(LeapMotionFunctionLibrary_eventSetImagePolicy_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapMotionFunctionLibrary_eventSetImagePolicy_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapMotionFunctionLibrary_eventSetImagePolicy_Parms), 0x0000000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapMotionFunctionLibrary_eventSetImagePolicy_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(UseImagePolicy, LeapMotionFunctionLibrary_eventSetImagePolicy_Parms, bool);
			UProperty* NewProp_UseImagePolicy = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("UseImagePolicy"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(UseImagePolicy, LeapMotionFunctionLibrary_eventSetImagePolicy_Parms), 0x0000000000000080, CPP_BOOL_PROPERTY_BITMASK(UseImagePolicy, LeapMotionFunctionLibrary_eventSetImagePolicy_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionFunctionLibrary.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enables or disables the Leap Motion Controller policy that transmits image data.\nNote that calling this function does not change the transforms of any\nLeapMotionControllerComponent instances that may exist.\n\n@param UseHmdPolicy          True to enable for image pass-through, false to disable.\n@returns                                     True if the device is connected."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapMotionFunctionLibrary_NoRegister()
	{
		return ULeapMotionFunctionLibrary::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapMotionFunctionLibrary()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UBlueprintFunctionLibrary();
			Z_Construct_UPackage_LeapMotionController();
			OuterClass = ULeapMotionFunctionLibrary::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetAllHandsIds());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetBonePostionAndOrientation());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetBoneWidthAndLength());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetGrabStrength());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetOldestLeftOrRightHandId());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetPinchStrength());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionFunctionLibrary_IsConnected());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionFunctionLibrary_SetHmdPolicy());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionFunctionLibrary_SetImagePolicy());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetAllHandsIds()); // 2840423616
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetBonePostionAndOrientation()); // 1240342624
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetBoneWidthAndLength()); // 2317958492
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetGrabStrength()); // 1189313020
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetOldestLeftOrRightHandId()); // 1878842472
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionFunctionLibrary_GetPinchStrength()); // 4246541544
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionFunctionLibrary_IsConnected()); // 1201478492
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionFunctionLibrary_SetHmdPolicy()); // 1510835670
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionFunctionLibrary_SetImagePolicy()); // 3125990353
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapMotionFunctionLibrary.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionFunctionLibrary.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("A C++ and Blueprint accessible library of utility functions for accessing Leap Motion device.\nAll positions & orientations are returned in Unreal reference frame & units, assuming the Leap device is located at the origin."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapMotionFunctionLibrary(Z_Construct_UClass_ULeapMotionFunctionLibrary, TEXT("ULeapMotionFunctionLibrary"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapMotionFunctionLibrary);
	UFunction* Z_Construct_UFunction_ALeapMotionHandActor_GetBoneActor()
	{
		struct LeapMotionHandActor_eventGetBoneActor_Parms
		{
			TEnumAsByte<ELeapBone> LeapBone;
			ALeapMotionBoneActor* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ALeapMotionHandActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetBoneActor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapMotionHandActor_eventGetBoneActor_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapMotionHandActor_eventGetBoneActor_Parms), 0x0000000000000580, Z_Construct_UClass_ALeapMotionBoneActor_NoRegister());
			UProperty* NewProp_LeapBone = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LeapBone"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(LeapBone, LeapMotionHandActor_eventGetBoneActor_Parms), 0x0000000000000080, Z_Construct_UEnum_LeapMotionController_ELeapBone());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Retrieves individual hand bone"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ALeapMotionHandActor_GetParentingControllerComponent()
	{
		struct LeapMotionHandActor_eventGetParentingControllerComponent_Parms
		{
			ULeapMotionControllerComponent* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ALeapMotionHandActor();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetParentingControllerComponent"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapMotionHandActor_eventGetParentingControllerComponent_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapMotionHandActor_eventGetParentingControllerComponent_Parms), 0x0000000000080588, Z_Construct_UClass_ULeapMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the parenting controller component that created this hand. This is based purely on actor/component attachment hierarchy"));
			MetaData->SetValue(NewProp_ReturnValue, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ALeapMotionHandActor_NoRegister()
	{
		return ALeapMotionHandActor::StaticClass();
	}
	UClass* Z_Construct_UClass_ALeapMotionHandActor()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_LeapMotionController();
			OuterClass = ALeapMotionHandActor::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_ALeapMotionHandActor_GetBoneActor());
				OuterClass->LinkChild(Z_Construct_UFunction_ALeapMotionHandActor_GetParentingControllerComponent());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_OnHandUpdated = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnHandUpdated"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnHandUpdated, ALeapMotionHandActor), 0x0000000010080000, Z_Construct_UDelegateFunction_LeapMotionController_LMHandUpdatedDelegate__DelegateSignature());
				UProperty* NewProp_OnHandRemoved = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnHandRemoved"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnHandRemoved, ALeapMotionHandActor), 0x0000000010080000, Z_Construct_UDelegateFunction_LeapMotionController_LMHandRemovedDelegate__DelegateSignature());
				UProperty* NewProp_OnHandAdded = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OnHandAdded"), RF_Public|RF_Transient|RF_Native) UMulticastDelegateProperty(CPP_PROPERTY_BASE(OnHandAdded, ALeapMotionHandActor), 0x0000000010080000, Z_Construct_UDelegateFunction_LeapMotionController_LMHandAddedDelegate__DelegateSignature());
				UProperty* NewProp_GrabStrength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GrabStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(GrabStrength, ALeapMotionHandActor), 0x0000000000020015);
				UProperty* NewProp_PinchStrength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PinchStrength"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(PinchStrength, ALeapMotionHandActor), 0x0000000000020015);
				UProperty* NewProp_HandSide = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HandSide"), RF_Public|RF_Transient|RF_Native) UByteProperty(CPP_PROPERTY_BASE(HandSide, ALeapMotionHandActor), 0x0000000000020015, Z_Construct_UEnum_LeapMotionController_ELeapSide());
				UProperty* NewProp_HandId = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HandId"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(HandId, ALeapMotionHandActor), 0x0000000000020015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShowArm, ALeapMotionHandActor, bool);
				UProperty* NewProp_bShowArm = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShowArm"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShowArm, ALeapMotionHandActor), 0x0000000000020015, CPP_BOOL_PROPERTY_BITMASK(bShowArm, ALeapMotionHandActor), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShowMesh, ALeapMotionHandActor, bool);
				UProperty* NewProp_bShowMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShowMesh"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShowMesh, ALeapMotionHandActor), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bShowMesh, ALeapMotionHandActor), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bShowCollider, ALeapMotionHandActor, bool);
				UProperty* NewProp_bShowCollider = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bShowCollider"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bShowCollider, ALeapMotionHandActor), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bShowCollider, ALeapMotionHandActor), sizeof(bool), true);
				UProperty* NewProp_Scale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Scale"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(Scale, ALeapMotionHandActor), 0x0000000000020015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ALeapMotionHandActor_GetBoneActor()); // 3290588674
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ALeapMotionHandActor_GetParentingControllerComponent()); // 840068477
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("LeapMotion"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapMotionHandActor.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("This actor is created dynamically by LeapMotionControllerComponent. It's location is same as the controller,\nhowever you can offset it to control hands' positions independently. To query hand's palm location in the Unreal scene,\naccess this actor's GetHandBoneActor(ELeapBone::Palm)."));
				MetaData->SetValue(NewProp_OnHandUpdated, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_OnHandUpdated, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(NewProp_OnHandUpdated, TEXT("ToolTip"), TEXT("Delegate triggered once per frame update"));
				MetaData->SetValue(NewProp_OnHandRemoved, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_OnHandRemoved, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(NewProp_OnHandRemoved, TEXT("ToolTip"), TEXT("Delegate triggered upon hand's destruction"));
				MetaData->SetValue(NewProp_OnHandAdded, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_OnHandAdded, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(NewProp_OnHandAdded, TEXT("ToolTip"), TEXT("Delegate triggered upon hand's creation"));
				MetaData->SetValue(NewProp_GrabStrength, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_GrabStrength, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(NewProp_GrabStrength, TEXT("ToolTip"), TEXT("Hand's grabbing strength, as reported by Leap API"));
				MetaData->SetValue(NewProp_PinchStrength, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_PinchStrength, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(NewProp_PinchStrength, TEXT("ToolTip"), TEXT("Hand's pinching strength, as reported by Leap API"));
				MetaData->SetValue(NewProp_HandSide, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_HandSide, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(NewProp_HandSide, TEXT("ToolTip"), TEXT("Is this a left or a right hand?"));
				MetaData->SetValue(NewProp_HandId, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_HandId, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(NewProp_HandId, TEXT("ToolTip"), TEXT("Hand's id, as reported by Leap API. Don't change it."));
				MetaData->SetValue(NewProp_bShowArm, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bShowArm, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(NewProp_bShowArm, TEXT("ToolTip"), TEXT("Show hand's arm. Don't change it."));
				MetaData->SetValue(NewProp_bShowMesh, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bShowMesh, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(NewProp_bShowMesh, TEXT("ToolTip"), TEXT("Visualize hand's mesh in game"));
				MetaData->SetValue(NewProp_bShowCollider, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bShowCollider, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(NewProp_bShowCollider, TEXT("ToolTip"), TEXT("Visualize hand's colliding shape in game"));
				MetaData->SetValue(NewProp_Scale, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_Scale, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionHandActor.h"));
				MetaData->SetValue(NewProp_Scale, TEXT("ToolTip"), TEXT("Scale of the hand, relatively to real-world size"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ALeapMotionHandActor(Z_Construct_UClass_ALeapMotionHandActor, TEXT("ALeapMotionHandActor"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ALeapMotionHandActor);
	UFunction* Z_Construct_UFunction_ULeapMotionImageComponent_AttachDisplaySurface()
	{
		UObject* Outer=Z_Construct_UClass_ULeapMotionImageComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AttachDisplaySurface"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x08020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("And event triggered when the display surface is attached to the PlayerCameraManager. You can overwrite the mesh type & its placement here"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapMotionImageComponent_UpdateImageTexture()
	{
		UObject* Outer=Z_Construct_UClass_ULeapMotionImageComponent();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UpdateImageTexture"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("LeapMotion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Trigger update of pass-through images"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapMotionImageComponent_NoRegister()
	{
		return ULeapMotionImageComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapMotionImageComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage_LeapMotionController();
			OuterClass = ULeapMotionImageComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionImageComponent_AttachDisplaySurface());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapMotionImageComponent_UpdateImageTexture());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_DistortionTextureRight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DistortionTextureRight"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DistortionTextureRight, ULeapMotionImageComponent), 0x0000000000020015, Z_Construct_UClass_UTexture2D_NoRegister());
				UProperty* NewProp_DistortionTextureLeft = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DistortionTextureLeft"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DistortionTextureLeft, ULeapMotionImageComponent), 0x0000000000020015, Z_Construct_UClass_UTexture2D_NoRegister());
				UProperty* NewProp_ImagePassthroughRight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ImagePassthroughRight"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ImagePassthroughRight, ULeapMotionImageComponent), 0x0000000000020015, Z_Construct_UClass_UTexture2D_NoRegister());
				UProperty* NewProp_ImagePassthroughLeft = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ImagePassthroughLeft"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ImagePassthroughLeft, ULeapMotionImageComponent), 0x0000000000020015, Z_Construct_UClass_UTexture2D_NoRegister());
				UProperty* NewProp_DynamicPassthroughMaterial = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DynamicPassthroughMaterial"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DynamicPassthroughMaterial, ULeapMotionImageComponent), 0x0000000000020015, Z_Construct_UClass_UMaterialInstanceDynamic_NoRegister());
				UProperty* NewProp_PassthroughMaterial = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PassthroughMaterial"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(PassthroughMaterial, ULeapMotionImageComponent), 0x0000000000000005, Z_Construct_UClass_UMaterialInterface_NoRegister());
				UProperty* NewProp_DisplaySurfaceComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DisplaySurfaceComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(DisplaySurfaceComponent, ULeapMotionImageComponent), 0x000000000008000d, Z_Construct_UClass_UStaticMeshComponent_NoRegister());
				UProperty* NewProp_DisplaySurfaceDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DisplaySurfaceDistance"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(DisplaySurfaceDistance, ULeapMotionImageComponent), 0x0000000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsPaused, ULeapMotionImageComponent, bool);
				UProperty* NewProp_bIsPaused = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIsPaused"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsPaused, ULeapMotionImageComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsPaused, ULeapMotionImageComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsVisible, ULeapMotionImageComponent, bool);
				UProperty* NewProp_bIsVisible = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bIsVisible"), RF_Public|RF_Transient|RF_Native) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsVisible, ULeapMotionImageComponent), 0x0000000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsVisible, ULeapMotionImageComponent), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionImageComponent_AttachDisplaySurface()); // 3546401091
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ULeapMotionImageComponent_UpdateImageTexture()); // 3645155253
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("LeapMotion"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("ComponentReplication"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapMotionImageComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Add this component to any actor to allow image from Leap Motion device's cameras to be displayed in the background of the scene."));
				MetaData->SetValue(NewProp_DistortionTextureRight, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_DistortionTextureRight, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
				MetaData->SetValue(NewProp_DistortionTextureRight, TEXT("ToolTip"), TEXT("Texture encoding lens distortion for the right camera"));
				MetaData->SetValue(NewProp_DistortionTextureLeft, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_DistortionTextureLeft, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
				MetaData->SetValue(NewProp_DistortionTextureLeft, TEXT("ToolTip"), TEXT("Texture encoding lens distortion for the left camera"));
				MetaData->SetValue(NewProp_ImagePassthroughRight, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_ImagePassthroughRight, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
				MetaData->SetValue(NewProp_ImagePassthroughRight, TEXT("ToolTip"), TEXT("Right raw image from the Leap device"));
				MetaData->SetValue(NewProp_ImagePassthroughLeft, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_ImagePassthroughLeft, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
				MetaData->SetValue(NewProp_ImagePassthroughLeft, TEXT("ToolTip"), TEXT("Left raw image from the Leap device"));
				MetaData->SetValue(NewProp_DynamicPassthroughMaterial, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_DynamicPassthroughMaterial, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
				MetaData->SetValue(NewProp_DynamicPassthroughMaterial, TEXT("ToolTip"), TEXT("Dynamic instance of the pass-through material"));
				MetaData->SetValue(NewProp_PassthroughMaterial, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_PassthroughMaterial, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
				MetaData->SetValue(NewProp_PassthroughMaterial, TEXT("ToolTip"), TEXT("Material template used to display the pass-through image"));
				MetaData->SetValue(NewProp_DisplaySurfaceComponent, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_DisplaySurfaceComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_DisplaySurfaceComponent, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
				MetaData->SetValue(NewProp_DisplaySurfaceComponent, TEXT("ToolTip"), TEXT("The mesh component with image display surface"));
				MetaData->SetValue(NewProp_DisplaySurfaceDistance, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_DisplaySurfaceDistance, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
				MetaData->SetValue(NewProp_DisplaySurfaceDistance, TEXT("ToolTip"), TEXT("Distance from the PlayerCameraManager at which the image display surface is placed"));
				MetaData->SetValue(NewProp_bIsPaused, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bIsPaused, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
				MetaData->SetValue(NewProp_bIsPaused, TEXT("ToolTip"), TEXT("Whether the image is paused"));
				MetaData->SetValue(NewProp_bIsVisible, TEXT("Category"), TEXT("LeapMotion"));
				MetaData->SetValue(NewProp_bIsVisible, TEXT("ModuleRelativePath"), TEXT("Public/LeapMotionImageComponent.h"));
				MetaData->SetValue(NewProp_bIsVisible, TEXT("ToolTip"), TEXT("Whether the image is displayed"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapMotionImageComponent(Z_Construct_UClass_ULeapMotionImageComponent, TEXT("ULeapMotionImageComponent"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapMotionImageComponent);
	UPackage* Z_Construct_UPackage_LeapMotionController()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/LeapMotionController")), false, false));
			ReturnPackage->PackageFlags |= PKG_CompiledIn | 0x00000000;
			FGuid Guid;
			Guid.A = 0xFDCE897F;
			Guid.B = 0x4ADE8F53;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

			Z_Construct_UDelegateFunction_LeapMotionController_LMHandAddedDelegate__DelegateSignature();
			Z_Construct_UDelegateFunction_LeapMotionController_LMHandRemovedDelegate__DelegateSignature();
			Z_Construct_UDelegateFunction_LeapMotionController_LMHandUpdatedDelegate__DelegateSignature();
		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
